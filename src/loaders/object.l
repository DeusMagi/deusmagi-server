%{
/*************************************************************************
 *           Atrinik, a Multiplayer Online Role Playing Game             *
 *                                                                       *
 *   Copyright (C) 2009-2014 Alex Tokar and Atrinik Development Team     *
 *                                                                       *
 * Fork from Crossfire (Multiplayer game for X-windows).                 *
 *                                                                       *
 * This program is free software; you can redistribute it and/or modify  *
 * it under the terms of the GNU General Public License as published by  *
 * the Free Software Foundation; either version 2 of the License, or     *
 * (at your option) any later version.                                   *
 *                                                                       *
 * This program is distributed in the hope that it will be useful,       *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 * GNU General Public License for more details.                          *
 *                                                                       *
 * You should have received a copy of the GNU General Public License     *
 * along with this program; if not, write to the Free Software           *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.             *
 *                                                                       *
 * The author can be reached at admin@atrinik.org                        *
 ************************************************************************/

/**
 * @file
 * C file generated by GNU Flex from loader.l, it handles object loading
 * related code.
 */

#include <global.h>
#include <loader.h>
#include <arch.h>
#include <artifact.h>
#include <toolkit/string.h>
#include <object.h>
#include <object_methods.h>
#include <sound_ambient.h>

#define YY_DECL                 \
static int                      \
lex_load (int     *depth,       \
          object **items,       \
          int      maxdepth,    \
          int      map_flags,   \
          int      linemode)
#define MAXDEPTH 10

static const char *yval(void);

/* that's needed to track the used buffers for recursive ccalling */
static void *cur_buffer;
static int lex_error;
static char msgbuf[HUGE_BUF * 4];
static size_t msgbuf_len;
static artifact_t *art_amask;

#define SET_ATTACK(op, type, val)  op->attack[type] = val;
#define SET_PROTECTION(op, type, val)  op->protection[type] = val;

/** Next value as integer. */
#define IVAL atoi(yval())
/** Next value as float. */
#define FVAL atof(yval())

#define YY_NO_INPUT

/**
 * This extracts the key/value from the yytext field - calls
 * object_set_value() to actually set the value.
 *
 * Function basically has to find spaces, strip out extra, etc. strchr()
 * doesn't work as good because could also be tabs.
 * @param op
 * Object in which to insert the value.
 */
static void add_key_value(object *op)
{
    char *key = NULL, *value = NULL, *cp, *end;

    /* First, skip over leading whitespace. */
    for (cp = yytext; isspace(*cp); cp++) {
    }

    key = cp;

    /* Now look for the end of the key/field name. */
    for ( ; !isspace(*cp); cp++) {
        if (*cp == '\0') {
            /* Oops, ran out of string! Set the key with an empty value. */
            object_set_value(op, key, NULL, 1);
            return;
        }
    }

    if (*cp == '\0') {
        object_set_value(op, key, NULL, 1);
        return;
    }

    /* Chop off the key, and start at the next character. */
    *cp = '\0';
    cp++;

    if (*cp == '\0') {
        /* Was followed by one space? */
        object_set_value(op, key, NULL, 1);
        return;
    }

    /* Now looking for the value. Skip over whitespace. */
    for ( ; isspace(*cp); cp++) {
        if (*cp == '\0') {
            /* Guess not. */
            object_set_value(op, key, NULL, 1);
            return;
        }
    }

    value = cp;

    /* Got last character before NULL and strip
     * off tailing whitespace */
    for (end = value + (strlen(cp) - 1); isspace(*end); end--) {
        if (end == value) {
            /* Still no value? */
            object_set_value(op, key, NULL, 1);
            return;
        }

        *end = '\0';
    }

    object_set_value(op, key, value, 1);
}

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wredundant-decls"
%}

LF  \x0A
CR  \x0D
NL  {CR}?{LF}

S   [ \t]+.+
WS  [ \t]*{NL}

%x MESSAGE

/* Don't have to link with -lfl with this */
%option noyywrap

/* Disable unput */
%option nounput

/* Disable tt_top_state */
%option noyy_top_state

/* need yy_push_state, yy_pop_state */
%option stack

%%

%{
int ismore = 0;
object *op = items[*depth];
lex_error = 0;
%}

^arch{S}             {
    object *tmp = op;

    if (tmp->arch != NULL) {
        tmp = object_get();
    }

    const char *archname = yval();
    tmp->arch = arch_find(archname);
    if (tmp->arch != NULL) {
        object_copy(tmp, &tmp->arch->clone, true);
    }

    if (tmp != op) {
        artifact_t *art_amask_tmp = art_amask;
        art_amask = NULL;

        if (linemode == 1) {
            (*depth)++;

            if (*depth >= MAXDEPTH) {
                log_error("Exhausted maximum items stack size, exiting...");
                exit(1);
            }
        }

        items[*depth] = tmp;

        if (linemode == 0) {
            lex_load(depth, items, maxdepth, map_flags, linemode);

            if (tmp->arch != NULL) {
                tmp = object_insert_into(tmp, op, 0);
            } else {
                if (!arch_in_init) {
                    LOG(DEBUG, "Discarding object without arch: %s", archname);
                }

                object_destroy(tmp);
                tmp = NULL;
            }
        }

        if (art_amask && tmp != NULL) {
            artifact_change_object(art_amask, tmp);
        }

        art_amask = art_amask_tmp;

        if (!(map_flags & MAP_STYLE) && tmp != NULL) {
            if (tmp->speed < 0.0 && tmp->arch != NULL &&
                    DBL_EQUAL(tmp->speed_left, tmp->arch->clone.speed_left)) {
                tmp->speed_left = tmp->arch->clone.speed_left +
                        rndm(0, 90) / 100.0f;
            }

            object_update_speed(tmp);
            object_cb_init(tmp);

            /* Process auto-apply items or generate treasure. */
            if (QUERY_FLAG(tmp, FLAG_AUTO_APPLY)) {
                object_auto_apply(tmp);
            } else if (tmp->randomitems != NULL && (map_flags & MAP_ORIGINAL) &&
                    op->type != SPAWN_POINT) {
                treasure_generate(tmp->randomitems,
                                  tmp,
                                  get_environment_level(tmp),
                                  0);
            }
        }
    }
}

^object{S}           {
    const char *yv = yval();

    if (*yv == '\0') {
        LOG(ERROR, "Object lacks name.");
        exit(1);
    }

    if (op->arch != NULL) {
        FREE_AND_COPY_HASH(op->arch->name, yv);
    }

    FREE_AND_COPY_HASH(op->name, yv);
}

^msg{WS}             {
    BEGIN(MESSAGE);
    msgbuf[0] = '\0';
    msgbuf_len = 0;
}
<MESSAGE>^endmsg{WS} {
    BEGIN(INITIAL);

    /* Remove last newline. */
    msgbuf[msgbuf_len - 1] = '\0';
    FREE_AND_COPY_HASH(op->msg, msgbuf);
}
<MESSAGE>.*{NL}      {
    memcpy(msgbuf + msgbuf_len, yytext, MIN((size_t) yyleng,
            sizeof(msgbuf) - msgbuf_len - 1));
    msgbuf_len += yyleng;
}
^name{S}             {
    const char *yv = yval();

    if (*yv == '\0') {
        LOG(ERROR, "Name without val");
    } else {
        FREE_AND_COPY_HASH(op->name, yv);
    }
}
^custom_name{S}      {
    const char *yv = yval();

    if (*yv == '\0') {
        LOG(ERROR, "Custom name without val.");
    } else {
        FREE_AND_COPY_HASH(op->custom_name, yv);

        if (op->custom_name == shstr_cons.NONE) {
            FREE_AND_CLEAR_HASH(op->custom_name);
        }
    }
}
^glow{S}      {
    const char *yv = yval();

    if (*yv == '\0') {
        LOG(ERROR, "Glow without val.");
    } else {
        FREE_AND_COPY_HASH(op->glow, yv);

        if (op->glow == shstr_cons.NONE) {
            FREE_AND_CLEAR_HASH(op->glow);
        }
    }
}
^race{S}             FREE_AND_COPY_HASH(op->race, yval());
^slaying{S}          {
    FREE_AND_COPY_HASH(op->slaying, yval());

    if (op->slaying == shstr_cons.NONE) {
        FREE_AND_CLEAR_HASH(op->slaying);
    }
}
^artifact{S}         FREE_AND_COPY_HASH(op->artifact, yval());
^amask{S}            {
    const char *yv = yval();

    if (*yv == '\0') {
        LOG(ERROR, "Artifact mask without val");
    } else if (op->arch != NULL) {
        art_amask = artifact_find_type(yval(), op->arch->clone.type);

        if (art_amask == NULL) {
            LOG(ERROR, "Invalid amask '%s'.", yval());
        }
    }
}
^quickslot{S}        op->quickslot = IVAL;
^other_arch{S}       op->other_arch = arch_find(yval());
^animation{S}        {
    const char *yv = yval();

    if (strcmp(yv, "NONE") == 0) {
        op->animation_id = 0;
    } else {
        op->animation_id = find_animation(yv);
    }
}
^inv_animation{S}    {
    const char *yv = yval();

    if (strcmp(yv, "NONE") == 0) {
        op->inv_animation_id = 0;
    } else {
        op->inv_animation_id = find_animation(yv);
    }
}

^more{WS}            {
    /* We need to record that this is a multipart object,
     * so the calling function can glue things back together. */
    ismore = 1;
}

^end{WS}             {
    if (linemode) {
        /* Linemode is only set for artifact loading. */
        if ((*depth) > 0) {
            object_insert_into(items[*depth], items[(*depth) - 1], 0);
        }

        return LL_NORMAL;
    }

    if (ismore) {
        return LL_MORE;
    } else {
        return LL_NORMAL;
    }
}
^object_int1{S}      op->enemy_count = IVAL;
^object_int2{S}      op->attacked_by_count = IVAL;
^object_int3{S}      op->ownercount = IVAL;
^last_heal{S}        op->last_heal = IVAL;
^last_sp{S}          op->last_sp = IVAL;
^last_grace{S}       op->last_grace = IVAL;
^last_grace_add{S}   op->last_grace += IVAL;
^last_eat{S}         op->last_eat = IVAL;
^speed{S}            op->speed = FVAL;
^speed_left{S}       op->speed_left = FVAL;
^slow_move{S}        CHANGE_FLAG(op, FLAG_SLOW_MOVE, IVAL);
^face{S}             {
    int _face_ = find_face(yval(), 0);
    op->face = &new_faces[_face_];

    if (_face_ == 0) {
        LOG(ERROR, "Can't find face %s for object: %s", yval(),
                object_get_str(op));
    }
}
^inv_face{S}         {
    int _face_ = find_face(yval(), 0);
    op->inv_face = &new_faces[_face_];

    if (_face_ == 0) {
        LOG(ERROR, "Can't find inv_face %s for object: %s", yval(),
                object_get_str(op));
    }
}
^str{S}              op->stats.Str = IVAL;
^dex{S}              op->stats.Dex = IVAL;
^con{S}              op->stats.Con = IVAL;
^int{S}              op->stats.Int = IVAL;
^pow{S}              op->stats.Pow = IVAL;
^hp{S}               op->stats.hp = IVAL;
^maxhp{S}            op->stats.maxhp = IVAL;
^sp{S}               op->stats.sp = IVAL;
^maxsp{S}            op->stats.maxsp = IVAL;
^exp{S}              op->stats.exp = atoll(yval());
^food{S}             op->stats.food = IVAL;
^dam{S}              op->stats.dam = IVAL;
^dam_add{S}          op->stats.dam += IVAL;
^wc{S}               op->stats.wc = IVAL;
^wc_add{S}           op->stats.wc += IVAL;
^wc_range{S}         op->stats.wc_range = IVAL;
^wc_range_add{S}     op->stats.wc_range += IVAL;
^ac{S}               op->stats.ac = IVAL;
^ac_add{S}           op->stats.ac += IVAL;
^x{S}                op->x = IVAL;
^y{S}                op->y = IVAL;
^z{S}                op->z = IVAL;
^zoom{S}             op->zoom_x = op->zoom_y = IVAL;
^zoom_x{S}           op->zoom_x = IVAL;
^zoom_y{S}           op->zoom_y = IVAL;
^align{S}            op->align = IVAL;
^alpha{S}            op->alpha = IVAL;
^glow_speed{S}       op->glow_speed = IVAL;
^rotate{S}           op->rotate = IVAL;
^nrof{S}             op->nrof = atol(yval());
^level{S}            op->level = IVAL;
^direction{S}        op->direction = (IVAL % 9);
^type{S}             op->type = IVAL;
^material{S}         op->material = IVAL;
^value{S}            op->value = atoll(yval());
^weight{S}           op->weight = atol(yval());
^carrying{S}         op->carrying = atol(yval());
^path_attuned{S}     op->path_attuned = IVAL;
^path_repelled{S}    op->path_repelled = IVAL;
^path_denied{S}      op->path_denied = IVAL;
^magic{S}            op->magic = IVAL;
^state{S}            op->state = IVAL;
^layer{S}            {
    int val = IVAL;
    op->layer = MAX(0, MIN(NUM_LAYERS, val));
}
^sub_layer{S}        {
    int val = IVAL;
    op->sub_layer = MAX(0, MIN(NUM_SUB_LAYERS - 1, val));
}
^door_closed{S}      CHANGE_FLAG(op, FLAG_DOOR_CLOSED, IVAL);
^cursed_perm{S}      CHANGE_FLAG(op, FLAG_PERM_CURSED, IVAL);
^damned_perm{S}      CHANGE_FLAG(op, FLAG_PERM_DAMNED, IVAL);
^one_drop{S}         CHANGE_FLAG(op, FLAG_ONE_DROP, IVAL);
^is_trapped{S}       CHANGE_FLAG(op, FLAG_IS_TRAPPED, IVAL);
^quest_item{S}       CHANGE_FLAG(op, FLAG_QUEST_ITEM, IVAL);
^player_only{S}      CHANGE_FLAG(op, FLAG_PLAYER_ONLY, IVAL);
^is_named{S}         CHANGE_FLAG(op, FLAG_IS_NAMED, IVAL);
^is_player{S}        CHANGE_FLAG(op, FLAG_IS_PLAYER, IVAL);
^sys_object{S}       CHANGE_FLAG(op, FLAG_SYS_OBJECT, IVAL);
^generator{S}        {}
^can_stack{S}        CHANGE_FLAG(op, FLAG_CAN_STACK, IVAL);
^is_thrown{S}        CHANGE_FLAG(op, FLAG_IS_THROWN, IVAL);
^auto_apply{S}       CHANGE_FLAG(op, FLAG_AUTO_APPLY, IVAL);
^treasure{S}         {}
^is_assassin{S}      CHANGE_FLAG(op, FLAG_IS_ASSASSINATION, IVAL);
^is_spell{S}         CHANGE_FLAG(op, FLAG_IS_SPELL, IVAL);
^is_missile{S}       CHANGE_FLAG(op, FLAG_IS_MISSILE, IVAL);
^draw_direction{S}   CHANGE_FLAG(op, FLAG_DRAW_DIRECTION, IVAL);
^draw_double{S}      CHANGE_FLAG(op, FLAG_DRAW_DOUBLE, IVAL);
^draw_double_always{S} CHANGE_FLAG(op, FLAG_DRAW_DOUBLE_ALWAYS, IVAL);
^see_invisible{S}    CHANGE_FLAG(op, FLAG_SEE_INVISIBLE, IVAL);
^make_invisible{S}   CHANGE_FLAG(op, FLAG_MAKE_INVISIBLE, IVAL);
^make_ethereal{S}    CHANGE_FLAG(op, FLAG_MAKE_ETHEREAL, IVAL);
^can_roll{S}         CHANGE_FLAG(op, FLAG_CAN_ROLL, IVAL);
^connect_reset{S}    CHANGE_FLAG(op, FLAG_CONNECT_RESET, IVAL);
^is_turnable{S}      CHANGE_FLAG(op, FLAG_IS_TURNABLE, IVAL);
^is_used_up{S}       CHANGE_FLAG(op, FLAG_IS_USED_UP, IVAL);
^is_invisible{S}     CHANGE_FLAG(op, FLAG_IS_INVISIBLE, IVAL);
^alive{S}            {}
^applied{S}          CHANGE_FLAG(op, FLAG_APPLIED, IVAL);
^unpaid{S}           CHANGE_FLAG(op, FLAG_UNPAID, IVAL);
^hidden{S}           CHANGE_FLAG(op, FLAG_HIDDEN, IVAL);
^no_pick{S}          CHANGE_FLAG(op, FLAG_NO_PICK, IVAL);
^no_pass{S}          CHANGE_FLAG(op, FLAG_NO_PASS, IVAL);
^no_teleport{S}      CHANGE_FLAG(op, FLAG_NO_TELEPORT, IVAL);
^corpse{S}           CHANGE_FLAG(op, FLAG_CORPSE, IVAL);
^corpse_forced{S}    CHANGE_FLAG(op, FLAG_CORPSE_FORCED, IVAL);
^walk_on{S}          CHANGE_FLAG(op, FLAG_WALK_ON, IVAL);
^walk_off{S}         CHANGE_FLAG(op, FLAG_WALK_OFF, IVAL);
^fly_on{S}           CHANGE_FLAG(op, FLAG_FLY_ON, IVAL);
^fly_off{S}          CHANGE_FLAG(op, FLAG_FLY_OFF, IVAL);
^is_animated{S}      CHANGE_FLAG(op, FLAG_ANIMATE, IVAL);
^flying{S}           CHANGE_FLAG(op, FLAG_FLYING, IVAL);
^monster{S}          CHANGE_FLAG(op, FLAG_MONSTER, IVAL);
^no_attack{S}        CHANGE_FLAG(op, FLAG_NO_ATTACK, IVAL);
^invulnerable{S}     CHANGE_FLAG(op, FLAG_INVULNERABLE, IVAL);
^friendly{S}         CHANGE_FLAG(op, FLAG_FRIENDLY, IVAL);
^identified{S}       CHANGE_FLAG(op, FLAG_IDENTIFIED, IVAL);
^reflecting{S}       CHANGE_FLAG(op, FLAG_REFLECTING, IVAL);
^changing{S}         CHANGE_FLAG(op, FLAG_CHANGING, IVAL);
^splitting{S}        CHANGE_FLAG(op, FLAG_SPLITTING, IVAL);
^hitback{S}          CHANGE_FLAG(op, FLAG_HITBACK, IVAL);
^startequip{S}       CHANGE_FLAG(op, FLAG_STARTEQUIP, IVAL);
^blocksview{S}       CHANGE_FLAG(op, FLAG_BLOCKSVIEW, IVAL);
^undead{S}           CHANGE_FLAG(op, FLAG_UNDEAD, IVAL);
^scared{S}           CHANGE_FLAG(op, FLAG_SCARED, IVAL);
^unaggressive{S}     CHANGE_FLAG(op, FLAG_UNAGGRESSIVE, IVAL);
^reflect_missile{S}  CHANGE_FLAG(op, FLAG_REFL_MISSILE, IVAL);
^reflect_spell{S}    CHANGE_FLAG(op, FLAG_REFL_SPELL, IVAL);
^can_reflect_missile{S} CHANGE_FLAG(op, FLAG_REFL_MISSILE, IVAL);
^can_reflect_spell{S} CHANGE_FLAG(op, FLAG_REFL_SPELL, IVAL);
^no_magic{S}         CHANGE_FLAG(op, FLAG_NO_MAGIC, IVAL);
^no_fix_player{S}    CHANGE_FLAG(op, FLAG_NO_FIX_PLAYER, IVAL);
^tear_down{S}        {}
^luck{S}             {}
^run_away{S}         op->run_away = IVAL;
^pass_thru{S}        CHANGE_FLAG(op, FLAG_PASS_THRU, IVAL);
^can_pass_thru{S}    CHANGE_FLAG(op, FLAG_CAN_PASS_THRU, IVAL);
^anim_speed{S}       op->anim_speed = IVAL;
^container{S}        op->weight_limit = IVAL;
^no_drop{S}          CHANGE_FLAG(op, FLAG_NO_DROP, IVAL);
^behavior{S}         op->behavior = IVAL;
^use_fix_pos{S}      CHANGE_FLAG(op, FLAG_USE_FIX_POS, IVAL);
^is_ethereal{S}      CHANGE_FLAG(op, FLAG_IS_ETHEREAL, IVAL);
^two_handed{S}       CHANGE_FLAG(op, FLAG_TWO_HANDED, IVAL);
^can_cast_spell{S}   CHANGE_FLAG(op, FLAG_CAST_SPELL, IVAL);
^can_use_scroll{S}   {}
^can_use_range{S}    {}
^can_use_bow{S}      CHANGE_FLAG(op, FLAG_USE_BOW, IVAL);
^can_use_armour{S}   CHANGE_FLAG(op, FLAG_USE_ARMOUR, IVAL);
^can_use_weapon{S}   CHANGE_FLAG(op, FLAG_USE_WEAPON, IVAL);
^can_use_ring{S}     {}
^has_ready_range{S}  {}
^has_ready_bow{S}    CHANGE_FLAG(op, FLAG_READY_BOW, IVAL);
^xrays{S}            CHANGE_FLAG(op, FLAG_XRAYS, IVAL);
^no_save{S}          CHANGE_FLAG(op, FLAG_NO_SAVE, IVAL);
^is_floor{S}         CHANGE_FLAG(op, FLAG_IS_FLOOR, IVAL);
^is_male{S}          CHANGE_FLAG(op, FLAG_IS_MALE, IVAL);
^is_female{S}        CHANGE_FLAG(op, FLAG_IS_FEMALE, IVAL);
^is_evil{S}          CHANGE_FLAG(op, FLAG_IS_EVIL, IVAL);
^is_good{S}          CHANGE_FLAG(op, FLAG_IS_GOOD, IVAL);
^is_neutral{S}       CHANGE_FLAG(op, FLAG_IS_NEUTRAL, IVAL);
^lifesave{S}         CHANGE_FLAG(op, FLAG_LIFESAVE, IVAL);
^sleep{S}            CHANGE_FLAG(op, FLAG_SLEEP, IVAL);
^stand_still{S}      CHANGE_FLAG(op, FLAG_STAND_STILL, IVAL);
^random_move{S}      CHANGE_FLAG(op, FLAG_RANDOM_MOVE, IVAL);
^only_attack{S}      CHANGE_FLAG(op, FLAG_ONLY_ATTACK, IVAL);
^berserk{S}          CHANGE_FLAG(op, FLAG_BERSERK, IVAL);
^is_magical{S}       CHANGE_FLAG(op, FLAG_IS_MAGICAL, IVAL);
^connect_no_push{S}  CHANGE_FLAG(op, FLAG_CONNECT_NO_PUSH, IVAL);
^connect_no_release{S} CHANGE_FLAG(op, FLAG_CONNECT_NO_RELEASE, IVAL);

    /* Start of various attacktypes */
^attack_impact{S}    SET_ATTACK(op, ATNR_IMPACT, IVAL);
^attack_slash{S}     SET_ATTACK(op, ATNR_SLASH, IVAL);
^attack_cleave{S}    SET_ATTACK(op, ATNR_CLEAVE, IVAL);
^attack_pierce{S}    SET_ATTACK(op, ATNR_PIERCE, IVAL);
^attack_weaponmagic{S} SET_ATTACK(op, ATNR_WEAPON_MAGIC, IVAL);

^attack_fire{S}      SET_ATTACK(op, ATNR_FIRE, IVAL);
^attack_cold{S}      SET_ATTACK(op, ATNR_COLD, IVAL);
^attack_electricity{S} SET_ATTACK(op, ATNR_ELECTRICITY, IVAL);
^attack_poison{S}    SET_ATTACK(op, ATNR_POISON, IVAL);
^attack_acid{S}      SET_ATTACK(op, ATNR_ACID, IVAL);

^attack_magic{S}     SET_ATTACK(op, ATNR_MAGIC, IVAL);
^attack_lifesteal{S} SET_ATTACK(op, ATNR_LIFESTEAL, IVAL);
^attack_blind{S}     SET_ATTACK(op, ATNR_BLIND, IVAL);
^attack_paralyze{S}  SET_ATTACK(op, ATNR_PARALYZE, IVAL);
^attack_force{S}     SET_ATTACK(op, ATNR_FORCE, IVAL);

^attack_godpower{S}  SET_ATTACK(op, ATNR_GODPOWER, IVAL);
^attack_chaos{S}     SET_ATTACK(op, ATNR_CHAOS, IVAL);
^attack_drain{S}     SET_ATTACK(op, ATNR_DRAIN, IVAL);
^attack_slow{S}      SET_ATTACK(op, ATNR_SLOW, IVAL);
^attack_confusion{S} SET_ATTACK(op, ATNR_CONFUSION, IVAL);

^attack_internal{S}  SET_ATTACK(op, ATNR_INTERNAL, IVAL);

    /* Start of various protections */
^protect_impact{S}   SET_PROTECTION(op, ATNR_IMPACT, IVAL);
^protect_slash{S}    SET_PROTECTION(op, ATNR_SLASH, IVAL);
^protect_cleave{S}   SET_PROTECTION(op, ATNR_CLEAVE, IVAL);
^protect_pierce{S}   SET_PROTECTION(op, ATNR_PIERCE, IVAL);
^protect_weaponmagic{S} SET_PROTECTION(op, ATNR_WEAPON_MAGIC, IVAL);

^protect_fire{S}     SET_PROTECTION(op, ATNR_FIRE, IVAL);
^protect_cold{S}     SET_PROTECTION(op, ATNR_COLD, IVAL);
^protect_electricity{S} SET_PROTECTION(op, ATNR_ELECTRICITY, IVAL);
^protect_poison{S}   SET_PROTECTION(op, ATNR_POISON, IVAL);
^protect_acid{S}     SET_PROTECTION(op, ATNR_ACID, IVAL);

^protect_magic{S}    SET_PROTECTION(op, ATNR_MAGIC, IVAL);
^protect_lifesteal{S} SET_PROTECTION(op, ATNR_LIFESTEAL, IVAL);
^protect_blind{S}    SET_PROTECTION(op, ATNR_BLIND, IVAL);
^protect_paralyze{S} SET_PROTECTION(op, ATNR_PARALYZE, IVAL);
^protect_force{S}    SET_PROTECTION(op, ATNR_FORCE, IVAL);

^protect_godpower{S} SET_PROTECTION(op, ATNR_GODPOWER, IVAL);
^protect_chaos{S}    SET_PROTECTION(op, ATNR_CHAOS, IVAL);
^protect_drain{S}    SET_PROTECTION(op, ATNR_DRAIN, IVAL);
^protect_slow{S}     SET_PROTECTION(op, ATNR_SLOW, IVAL);
^protect_confusion{S} SET_PROTECTION(op, ATNR_CONFUSION, IVAL);

^protect_internal{S} SET_PROTECTION(op, ATNR_INTERNAL, IVAL);

    /* The following protections are deprecated, and are here only
     * for backwards compatibility.
     * TODO remove these at some point. */
^protect_body{S}     SET_PROTECTION(op, ATNR_BLIND, IVAL);
^protect_psionic{S}  SET_PROTECTION(op, ATNR_PARALYZE, IVAL);
^protect_corruption{S} SET_PROTECTION(op, ATNR_CONFUSION, IVAL);
^protect_spiritual{S} SET_PROTECTION(op, ATNR_PARALYZE, IVAL);
^protect_death{S}    SET_PROTECTION(op, ATNR_DRAIN, IVAL);

^movement_type{S}    op->move_type = IVAL;
^attack_move_type{S} op->attack_move_type = IVAL;

^move_state{S}       op->move_status = IVAL;
^confused{S}         CHANGE_FLAG(op, FLAG_CONFUSED, IVAL);
^stealth{S}          CHANGE_FLAG(op, FLAG_STEALTH, IVAL);
^connected{S}        connection_object_add(op, op->map, IVAL);
^cursed{S}           CHANGE_FLAG(op, FLAG_CURSED, IVAL);
^damned{S}           CHANGE_FLAG(op, FLAG_DAMNED, IVAL);
^is_buildable{S}     CHANGE_FLAG(op, FLAG_IS_BUILDABLE, IVAL);
^no_pvp{S}           CHANGE_FLAG(op, FLAG_NO_PVP, IVAL);
^known_magical{S}    {/* DEPRECATED */}
^known_cursed{S}     {/* DEPRECATED */}
^attacktype{S}       {/* DEPRECATED */}
^can_use_skill{S}    {/* DEPRECATED */}
^been_applied{S}     CHANGE_FLAG(op, FLAG_BEEN_APPLIED, IVAL);
^title{S}            {
    const char *y = yval();

    if (*y == '\0') {
        LOG(ERROR, "Title without value.");
    } else {
        FREE_AND_COPY_HASH(op->title, y);

        if (op->title == shstr_cons.NONE) {
            FREE_AND_CLEAR_HASH(op->title);
        }
    }
}
^outdoor{S}          CHANGE_FLAG(op, FLAG_OUTDOOR, IVAL);
^unique{S}           CHANGE_FLAG(op, FLAG_UNIQUE, IVAL);
^inv_locked{S}       CHANGE_FLAG(op, FLAG_INV_LOCKED, IVAL);
^is_wooded{S}        {/* DEPRECATED */}
^is_hilly{S}         {/* DEPRECATED */}
^has_ready_skill{S}  {/* DEPRECATED */}
^has_ready_weapon{S} CHANGE_FLAG(op, FLAG_READY_WEAPON, IVAL);
^no_skill_ident{S}   CHANGE_FLAG(op, FLAG_NO_SKILL_IDENT, IVAL);
^glow_radius{S}      op->glow_radius = IVAL;
^is_blind{S}         CHANGE_FLAG(op, FLAG_BLIND, IVAL);
^can_see_in_dark{S}  CHANGE_FLAG(op, FLAG_SEE_IN_DARK, IVAL);
^is_cauldron{S}      CHANGE_FLAG(op, FLAG_IS_CAULDRON, IVAL);
^randomitems{S}      op->randomitems = treasure_list_find(yval());
^is_dust{S}          CHANGE_FLAG(op, FLAG_DUST, IVAL);
^no_steal{S}         {/* DEPRECATED */}
^one_hit{S}          CHANGE_FLAG(op, FLAG_ONE_HIT, IVAL);
^is_vul_elemental{S} {/* DEPRECATED */}
^is_proof_elemental{S} {/* DEPRECATED */}
^is_vul_magic{S}     {/* DEPRECATED */}
^is_proof_magic{S}   {/* DEPRECATED */}
^is_vul_physical{S}  {/* DEPRECATED */}
^is_proof_physical{S} {/* DEPRECATED */}
^is_vul_sphere{S}    {/* DEPRECATED */}
^is_proof_sphere{S}  {/* DEPRECATED */}
^is_indestructible{S} CHANGE_FLAG(op, FLAG_INDESTRUCTIBLE, IVAL);
^soulbound{S}        CHANGE_FLAG(op, FLAG_SOULBOUND, IVAL);

    /* Ignore editor_folder values. */
^editor_folder{S}    {}
^sub_type{S}         op->sub_type = IVAL;
^terrain_flag{S}     op->terrain_flag = IVAL;
^terrain_type{S}     op->terrain_type = IVAL;
^item_quality{S}     op->item_quality = IVAL;
^item_condition{S}   op->item_condition = IVAL;
^item_race{S}        op->item_race = IVAL;
^item_skill{S}       op->item_skill = IVAL;
^item_level{S}       op->item_level = IVAL;
^item_level_art{S}   {
    /* Artifact list token - Never use in real arches or maps. */
    int ival_tmp = IVAL;

    /* When we have an artifact which has a minimum use level of 10
     * but we give it a mithril armour of default use level 50,
     * we will create artifact mithril armour usable for level 10!
     * This code prevents such things from happening. */
    if (ival_tmp <= 0) {
        op->item_level = -ival_tmp;
    } else if (ival_tmp > op->item_level) {
        op->item_level = ival_tmp;
    }
}
^material_real{S}    {
    op->material_real = IVAL;

    if (op->item_quality == 0) {
        op->item_quality = materials_real[op->material_real].quality;
        op->item_condition = op->item_quality;
    }
}
^mpart_id{S}         op->quick_pos |= IVAL << 4;
^mpart_nr{S}         op->quick_pos |= IVAL;
^weapon_speed{S}     {
    op->weapon_speed = FVAL;
    op->weapon_speed_left = 0.0;
}
^item_power{S}       op->item_power = IVAL;
^match{S}            {
    sound_ambient_match_parse(op, yval());
}
^block{S}            op->block = IVAL;
^block_add{S}        op->block += IVAL;
^absorb{S}           op->absorb = IVAL;
^absorb_add{S}       op->absorb += IVAL;

<*>(^{WS})|{NL}      {}
#.*{NL}              {}

<<EOF>>              {
    /* If we got an error, return the error. Otherwise, return that we got
     * EOF. */
    if (lex_error != 0) {
        return lex_error;
    }
    else {
        return LL_EOF;
    }
}
.*                   add_key_value(op);
%%

#pragma GCC diagnostic pop

/**
 * Returns the next token for lex.
 *
 * Our save file syntax is very simple, so we can use a very simple
 * processing mechanism here instead using something like bison.
 *
 * This skips over the space and returns the value, or "" if no value is
 * found.
 */
static const char *
yval (void)
{
    static const char *em = "";
    char *cp, *end;
    size_t len = yyleng;

    /* First skip over start of line, like animation or name */
    for (cp = yytext; *cp != ' '; cp++, len--) {
        if (*cp == '\0') {
            return em;
        }
    }

    /* Skip over whitespace */
    for (; *cp == ' '; cp++, len--) {
        if (*cp == '\0') {
            return em;
        }
    }

    /* Get last character before null and strip
     * off trailing whitespace. */
    for (end = cp + len - 1; *end == ' ' || *end == 0x0A || *end == 0x0D;
            end--) {
        if (end == cp) {
            return em;
        }

        *end = '\0';
    }

    return cp;
}

/**
 * Frees all memory allocated by the object loader.
 */
void
free_object_loader (void)
{
#ifndef WIN32
    yylex_destroy();
#endif
}

/* Buffer functions - needed to make load_object() recursive save. */
void
delete_loader_buffer (void *buffer)
{
    if (buffer != NULL) {
        yy_delete_buffer(buffer);
    } else {
        yy_delete_buffer(YY_CURRENT_BUFFER);
    }

    cur_buffer = NULL;
}

void *
create_loader_buffer (FILE *fp)
{
    HARD_ASSERT(fp != NULL);
    cur_buffer = yy_create_buffer(fp, YY_BUF_SIZE);
    yy_switch_to_buffer(cur_buffer);

    return cur_buffer;
}

/**
 * Begin loading an object; sets up the necessary state variables.
 *
 * @param op
 * Object that is to be loaded.
 * @param items
 * Objects array.
 */
static void
load_object_begin (object *op, object **items)
{
    HARD_ASSERT(op != NULL);

    items[0] = op;
    art_amask = NULL;
}

/**
 * Finish loading an object.
 *
 * @param op
 * Object that is to be loaded.
 * @param map_flags
 * Load flags.
 */
static void
load_object_finish (object *op, int map_flags)
{
    HARD_ASSERT(op != NULL);

    if (!(map_flags & MAP_STYLE)) {
        if (op->speed < 0.0 && DBL_EQUAL(op->speed_left,
                                         op->arch->clone.speed_left)) {
            op->speed_left = op->speed_left + rndm(0, 90) / 100.0f;
        }

        if (art_amask != NULL) {
            artifact_change_object(art_amask, op);
        }

        object_update_speed(op);
        object_cb_init(op);
    }
}

/**
 * Loads an object from the given string.
 *
 * Variables will be read, parsed and patched into the object until the
 * string "end" is reached, or the end of the string.
 *
 * @param str
 * String to load from.
 * @param op
 * Object to load into.
 * @param map_flags
 * Load flags.
 * @return
 * One of @ref LL_xxx.
 */
int
load_object (const char *str, object *op, int map_flags)
{
    HARD_ASSERT(str != NULL);
    HARD_ASSERT(op != NULL);

    static object *items[MAXDEPTH];
    int depth = 0;

    load_object_begin(op, items);

    size_t lcount = 0;

    for ( ; ; ) {
        str += lcount;
        lcount = strlen(str) + 1;
        YY_BUFFER_STATE yybufstate = yy_scan_string(str);
        int retval = lex_load(&depth, items, MAXDEPTH, map_flags, 0);
        yy_delete_buffer(yybufstate);

        if (retval == LL_NORMAL) {
            break;
        }
    }

    /* Be sure we work on the right buffer */
    if (cur_buffer != NULL) {
        yy_switch_to_buffer(cur_buffer);
    }

    load_object_finish(op, map_flags);
    return LL_NORMAL;
}

/**
 * Loads an object from the given file pointer.
 *
 * Variables will be read, parsed and patched into the object until the
 * string "end" is reached, or the end of the file.
 *
 * @param fp
 * File to load from.
 * @param op
 * Object to load into.
 * @param map_flags
 * Load flags.
 * @return
 * One of @ref LL_xxx.
 */
int
load_object_fp (FILE *fp, object *op, int map_flags)
{
    HARD_ASSERT(fp != NULL);
    HARD_ASSERT(op != NULL);

    static object *items[MAXDEPTH];
    int depth = 0;

    load_object_begin(op, items);

    static char buf[HUGE_BUF * 16];
    int retval = LL_EOF;
    while (fgets(VS(buf), fp)) {
        YY_BUFFER_STATE yybufstate = yy_scan_string(buf);
        retval = lex_load(&depth, items, MAXDEPTH, map_flags, 1);
        yy_delete_buffer(yybufstate);

        if (retval == LL_NORMAL) {
            /* Be sure we work on the right buffer */
            if (cur_buffer != NULL) {
                yy_switch_to_buffer(cur_buffer);
            }

            if (depth == 0) {
                return retval;
            } else {
                depth--;
            }
        }
    }

    LOG(ERROR, "Got EOF while scanning strings (%d)", retval);

    /* Be sure we work on the right buffer */
    if (cur_buffer != NULL) {
        yy_switch_to_buffer(cur_buffer);
    }

    return LL_EOF;
}

/**
 * Loads an object from the given flex buffer.
 *
 * Variables will be read, parsed and patched into the object until the
 * string "end" is reached, or the end of the file.
 *
 * @param buffer
 * Buffer to load from.
 * @param op
 * Object to load into.
 * @param map_flags
 * Load flags.
 * @return
 * One of @ref LL_xxx.
 */
int
load_object_buffer (void *buffer, object *op, int map_flags)
{
    HARD_ASSERT(buffer != NULL);
    HARD_ASSERT(op != NULL);

    static object *items[MAXDEPTH];
    load_object_begin(op, items);

    /* Be sure we work on the right buffer */
    if (cur_buffer != buffer) {
        cur_buffer = buffer;
        yy_switch_to_buffer(buffer);
    }

    int depth = 0;
    int retval = lex_load(&depth, items, MAXDEPTH, map_flags, 0);
    load_object_finish(op, map_flags);
    return retval;
}

/**
 * This takes a buffer, scans it for variables, and sets those variables
 * as appropriate in op.
 *
 * @param op
 * Object to alter.
 * @param buf
 * Modifications to apply.
 */
int
set_variable (object *op, const char *buf)
{
    YY_BUFFER_STATE yycurbuf = YY_CURRENT_BUFFER;
    yy_push_state(INITIAL);
    YY_BUFFER_STATE yybufstate = yy_scan_string(buf);

    object *items[MAXDEPTH];
    items[0] = op;
    int depth = 0;
    int retval = lex_load(&depth, items, MAXDEPTH, 0, 0);

    if (yycurbuf != NULL) {
        yy_switch_to_buffer(yycurbuf);
    }

    yy_delete_buffer(yybufstate);
    yy_pop_state();

    return retval;
}

/**
 * Generic value saver.
 */
#define SAVE_VALUE(_sb, _name, _value, _fmt) \
    do { \
        stringbuffer_append_printf((_sb), "%s " _fmt "\n", (_name), (_value)); \
    } while (0)
/**
 * Save a string to the specified StringBuffer instance.
 */
#define SAVE_STRING(_sb, _name, _value) SAVE_VALUE(_sb, _name, _value, "%s")
/**
 * Save a double to the specified StringBuffer instance.
 */
#define SAVE_DOUBLE(_sb, _name, _value) SAVE_VALUE(_sb, _name, _value, "%f")
/**
 * Save an int to the specified StringBuffer instance.
 */
#define SAVE_INT(_sb, _name, _value) SAVE_VALUE(_sb, _name, _value, "%d")
/**
 * Save an unsigned int to the specified StringBuffer instance.
 */
#define SAVE_UINT(_sb, _name, _value) SAVE_VALUE(_sb, _name, _value, "%u")
/**
 * Save a 64-bit int to the specified StringBuffer instance.
 */
#define SAVE_INT64(_sb, _name, _value) \
    SAVE_VALUE(_sb, _name, _value, "%" PRId64)
/**
 * Save an unsigned 64-bit int to the specified StringBuffer instance.
 */
#define SAVE_UINT64(_sb, _name, _value) \
    SAVE_VALUE(_sb, _name, _value, "%" PRIu64)

/**
 * Get difference between two objects, and save it in a StringBuffer instance.
 *
 * This function is typically used to dump objects (op2 = empty object),
 * or to save objects (op2 is the objects original archetype).
 *
 * @param sb
 * String buffer to modify.
 * @param op
 * What object the different values will be taken from.
 * @param op2
 * Object's original archetype.
 */
void
get_ob_diff (StringBuffer *sb, const object *op, const object *op2)
{
    HARD_ASSERT(sb != NULL);
    HARD_ASSERT(op != NULL);
    HARD_ASSERT(op2 != NULL);

    /* This saves the key/value lists. We do it first so that any
     * keys that match field names will be overwritten by the loader. */
    key_value_t *field;
    LL_FOREACH(op->key_values, field) {
        /* Find the field in the opposing member. */
        key_value_t *arch_field = object_get_key_link(op2, field->key);

        /* If there's no partnering field, or it's got a different value,
         * save our field. */
        if (arch_field == NULL || field->value != arch_field->value) {
            stringbuffer_append_string(sb, field->key);
            stringbuffer_append_string(sb, " ");

            if (field->value != NULL) {
                stringbuffer_append_string(sb, field->value);
            }

            stringbuffer_append_string(sb, "\n");
        }
    }

    if (op->name && op->name != op2->name) {
        SAVE_STRING(sb, "name", op->name);
    }

    if (op->custom_name && op->custom_name != op2->custom_name) {
        SAVE_STRING(sb, "custom_name", op->custom_name);
    }

    if (op->glow && op->glow != op2->glow) {
        SAVE_STRING(sb, "glow", op->glow);
    }

    if (op->title && op->title != op2->title) {
        SAVE_STRING(sb, "title", op->title);
    }

    if (op->race && op->race != op2->race) {
        SAVE_STRING(sb, "race", op->race);
    }

    if (op->slaying && op->slaying != op2->slaying) {
        SAVE_STRING(sb, "slaying", op->slaying);
    }

    if (op->msg && op->msg != op2->msg) {
        stringbuffer_append_string(sb, "msg\n");
        stringbuffer_append_string(sb, op->msg);
        stringbuffer_append_string(sb, "\nendmsg\n");
    }

    if (op->artifact && op->artifact != op2->artifact) {
        SAVE_STRING(sb, "artifact", op->artifact);
    }

    if (op->other_arch != op2->other_arch) {
        if (op->other_arch != NULL && op->other_arch->name != NULL) {
            SAVE_STRING(sb, "other_arch", op->other_arch->name);
        }
    }

    if (op->face != op2->face) {
        SAVE_STRING(sb, "face", op->face->name);
    }

    if (op->inv_face != op2->inv_face) {
        SAVE_STRING(sb, "inv_face", op->inv_face->name);
    }

    if (op->animation_id != op2->animation_id) {
        if (op->animation_id != 0) {
            SAVE_STRING(sb, "animation", animations[GET_ANIM_ID(op)].name);
        } else {
            stringbuffer_append_string(sb, "animation NONE\n");
        }
    }

    if (op->inv_animation_id != op2->inv_animation_id) {
        if (op->inv_animation_id != 0) {
            SAVE_STRING(sb,
                        "inv_animation",
                        animations[GET_INV_ANIM_ID(op)].name);
        } else {
            stringbuffer_append_string(sb, "inv_animation NONE\n");
        }
    }

    if (op->anim_speed != op2->anim_speed) {
        SAVE_UINT(sb, "anim_speed", op->anim_speed);
    }

    if (op->stats.wc_range != op2->stats.wc_range) {
        SAVE_UINT(sb, "wc_range", op->stats.wc_range);
    }

    if (op->stats.Str != op2->stats.Str) {
        SAVE_INT(sb, "Str", op->stats.Str);
    }

    if (op->stats.Dex != op2->stats.Dex) {
        SAVE_INT(sb, "Dex", op->stats.Dex);
    }

    if (op->stats.Con != op2->stats.Con) {
        SAVE_INT(sb, "Con", op->stats.Con);
    }

    if (op->stats.Pow != op2->stats.Pow) {
        SAVE_INT(sb, "Pow", op->stats.Pow);
    }

    if (op->stats.Int != op2->stats.Int) {
        SAVE_INT(sb, "Int", op->stats.Int);
    }

    if (op->stats.hp != op2->stats.hp) {
        SAVE_INT(sb, "hp", op->stats.hp);
    }

    if (op->stats.maxhp != op2->stats.maxhp) {
        SAVE_INT(sb, "maxhp", op->stats.maxhp);
    }

    if (op->stats.sp != op2->stats.sp) {
        SAVE_INT(sb, "sp", op->stats.sp);
    }

    if (op->stats.maxsp != op2->stats.maxsp) {
        SAVE_INT(sb, "maxsp", op->stats.maxsp);
    }

    if (op->stats.exp != op2->stats.exp) {
        SAVE_INT64(sb, "exp", op->stats.exp);
    }

    if (op->stats.food != op2->stats.food) {
        SAVE_INT(sb, "food", op->stats.food);
    }

    if (op->stats.dam != op2->stats.dam) {
        SAVE_INT(sb, "dam", op->stats.dam);
    }

    if (op->stats.wc != op2->stats.wc) {
        SAVE_INT(sb, "wc", op->stats.wc);
    }

    if (op->stats.ac != op2->stats.ac) {
        SAVE_INT(sb, "ac", op->stats.ac);
    }

    if (op->x != op2->x) {
        SAVE_INT(sb, "x", op->x);
    }

    if (op->y != op2->y) {
        SAVE_INT(sb, "y", op->y);
    }

    if (op->z != op2->z) {
        SAVE_INT(sb, "z", op->z);
    }

    if (op->zoom_x != op2->zoom_x) {
        SAVE_INT(sb, "zoom_x", op->zoom_x);
    }

    if (op->zoom_y != op2->zoom_y) {
        SAVE_INT(sb, "zoom_y", op->zoom_y);
    }

    if (op->align != op2->align) {
        SAVE_INT(sb, "align", op->align);
    }

    if (op->alpha != op2->alpha) {
        SAVE_UINT(sb, "alpha", op->alpha);
    }

    if (op->glow_speed != op2->glow_speed) {
        SAVE_UINT(sb, "glow_speed", op->glow_speed);
    }

    if (op->rotate != op2->rotate) {
        SAVE_INT(sb, "rotate", op->rotate);
    }

    if (!DBL_EQUAL(op->speed, op2->speed)) {
        SAVE_DOUBLE(sb, "speed", op->speed);
    }

    if (!DBL_EQUAL(op->speed_left, op2->speed_left)) {
        SAVE_DOUBLE(sb, "speed_left", op->speed_left);
    }

    if (op->material_real != op2->material_real) {
        SAVE_INT(sb, "material_real", op->material_real);
    }

    if (op->sub_type != op2->sub_type) {
        SAVE_UINT(sb, "sub_type", op->sub_type);
    }

    if (op->terrain_flag != op2->terrain_flag) {
        SAVE_UINT(sb, "terrain_flag", op->terrain_flag);
    }

    if (op->terrain_type != op2->terrain_type) {
        SAVE_UINT(sb, "terrain_type", op->terrain_type);
    }

    if (op->item_quality != op2->item_quality) {
        SAVE_UINT(sb, "item_quality", op->item_quality);
    }

    if (op->item_condition != op2->item_condition) {
        SAVE_UINT(sb, "item_condition", op->item_condition);
    }

    if (op->item_race != op2->item_race) {
        SAVE_UINT(sb, "item_race", op->item_race);
    }

    if (op->item_skill != op2->item_skill) {
        SAVE_UINT(sb, "item_skill", op->item_skill);
    }

    if (op->item_level != op2->item_level) {
        SAVE_UINT(sb, "item_level", op->item_level);
    }

    if (!DBL_EQUAL(op->weapon_speed, op2->weapon_speed)) {
        SAVE_DOUBLE(sb, "weapon_speed", op->weapon_speed);
    }

    if (op->enemy_count != op2->enemy_count) {
        SAVE_UINT(sb, "object_int1", op->enemy_count);
    }

    if (op->attacked_by_count != op2->attacked_by_count) {
        SAVE_UINT(sb, "object_int2", op->attacked_by_count);
    }

    if (op->ownercount != op2->ownercount) {
        SAVE_UINT(sb, "object_int3", op->ownercount);
    }

    if (op->move_status != op2->move_status) {
        SAVE_INT(sb, "move_state", op->move_status);
    }

    if (op->move_type != op2->move_type) {
        SAVE_UINT(sb, "movement_type", op->move_type);
    }

    if (op->attack_move_type != op2->attack_move_type) {
        SAVE_UINT(sb, "attack_move_type", op->attack_move_type);
    }

    if (op->nrof != op2->nrof) {
        SAVE_UINT(sb, "nrof", op->nrof);
    }

    if (op->level != op2->level) {
        SAVE_INT(sb, "level", op->level);
    }

    if (op->direction != op2->direction) {
        SAVE_INT(sb, "direction", op->direction);
    }

    if (op->type != op2->type) {
        SAVE_UINT(sb, "type", op->type);
    }

    /* attack_save[] holds the attack form also for attack_xx */
    for (int tmp = 0; tmp < NROFATTACKS; tmp++) {
        if (op->attack[tmp] != op2->attack[tmp]) {
            stringbuffer_append_printf(sb,
                                       "attack_%s %u\n",
                                       attack_save[tmp],
                                       op->attack[tmp]);
        }

        if (op->protection[tmp] != op2->protection[tmp]) {
            stringbuffer_append_printf(sb,
                                       "protect_%s %d\n",
                                       attack_save[tmp],
                                       op->protection[tmp]);
        }
    }

    if (op->layer != op2->layer) {
        SAVE_UINT(sb, "layer", op->layer);
    }

    if (op->sub_layer != op2->sub_layer) {
        SAVE_UINT(sb, "sub_layer", op->sub_layer);
    }

    if (op->path_attuned != op2->path_attuned) {
        SAVE_UINT(sb, "path_attuned", op->path_attuned);
    }

    if (op->path_repelled != op2->path_repelled) {
        SAVE_UINT(sb, "path_repelled", op->path_repelled);
    }

    if (op->path_denied != op2->path_denied) {
        SAVE_UINT(sb, "path_denied", op->path_denied);
    }

    if (op->material != op2->material) {
        SAVE_UINT(sb, "material", op->material);
    }

    if (op->value != op2->value) {
        SAVE_INT64(sb, "value", op->value);
    }

    if (op->carrying != op2->carrying) {
        SAVE_UINT(sb, "carrying", op->carrying);
    }

    if (op->weight != op2->weight) {
        SAVE_UINT(sb, "weight", op->weight);
    }

    if (op->state != op2->state) {
        SAVE_UINT(sb, "state", op->state);
    }

    if (op->magic != op2->magic) {
        SAVE_INT(sb, "magic", op->magic);
    }

    if (op->last_heal != op2->last_heal) {
        SAVE_INT(sb, "last_heal", op->last_heal);
    }

    if (op->last_sp != op2->last_sp) {
        SAVE_INT(sb, "last_sp", op->last_sp);
    }

    if (op->last_grace != op2->last_grace) {
        SAVE_INT(sb, "last_grace", op->last_grace);
    }

    if (op->last_eat != op2->last_eat) {
        SAVE_INT(sb, "last_eat", op->last_eat);
    }

    if (QUERY_FLAG(op, FLAG_IS_LINKED)) {
        int tmp = connection_object_get_value(op);

        if (tmp != 0) {
            SAVE_INT(sb, "connected", tmp);
        }
    }

    if (op->glow_radius != op2->glow_radius) {
        SAVE_INT(sb, "glow_radius", op->glow_radius);
    }

    if (op->randomitems != op2->randomitems) {
        SAVE_STRING(sb,
                    "randomitems",
                    op->randomitems != NULL ? op->randomitems->name : "none");
    }

    if (op->run_away != op2->run_away) {
        SAVE_UINT(sb, "run_away", op->run_away);
    }

    if (op->weight_limit != op2->weight_limit) {
        SAVE_UINT(sb, "container", op->weight_limit);
    }

    if (op->behavior != op2->behavior) {
        SAVE_UINT(sb, "behavior", op->behavior);
    }

    if (op->quickslot != op2->quickslot) {
        SAVE_UINT(sb, "quickslot", op->quickslot);
    }

    if (op->item_power != op2->item_power) {
        SAVE_INT(sb, "item_power", op->item_power);
    }

    if (op->block != op2->block) {
        SAVE_INT(sb, "block", op->block);
    }

    if (op->absorb != op2->absorb) {
        SAVE_INT(sb, "absorb", op->absorb);
    }

    for (int tmp = 0; tmp <= NUM_FLAGS; tmp++) {
        if (object_flag_names[tmp] == NULL) {
            continue;
        }

        uint32_t flag = QUERY_FLAG(op, tmp);
        if (flag != QUERY_FLAG(op2, tmp)) {
            SAVE_STRING(sb, object_flag_names[tmp], flag ? "1" : "0");
        }
    }
}
